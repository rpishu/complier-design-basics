# complier-design-basics
COMPANY: CODTECH IT SOLUTIONS
NAME: Rishu Priyadarshi
INTERN ID:
DURATION: 4WEEKS
MENTOR: NEELA SANTHOSH KUMAR
A compiler is software that translates or converts a program written in a high-level language (Source Language) into a low-level language (Machine Language or Assembly Language). Compiler design is the process of developing a compiler.

compilerDesignDiagram
The development of compilers is closely tied to the evolution of programming languages and computer science itself. Here's an overview of how compilers came into existence:

History of Compilers
In the 1950s, Grace Hopper developed the first compiler, leading to languages like FORTRAN (1957), LISP (1958), and COBOL (1959). The 1960s saw innovations like ALGOL, and the 1970s introduced C and Pascal. Modern compilers focus on optimization, supporting object-oriented features and Just-in-Time compilation. Compilers have revolutionized programming, enabling complex systems and improving software efficiency.

Role of Compilers
A program written in a high-level language cannot run without compilation. Each programming language has its own compiler, but the fundamental tasks performed by all compilers remain the same. Translating source code into machine code involves multiple stages, such as lexical analysis, syntax analysis, semantic analysis, code generation, and optimization.

While compilers are specialized, they differ from general translators. A translator or language processor is a tool that converts an input program written in one programming language into an equivalent program in another language.

Language Processing Systems
We know a computer is a logical assembly of Software and Hardware. The hardware knows a language, that is hard for us to grasp, consequently, we tend to write programs in a high-level language, that is much less complicated for us to comprehend and maintain in our thoughts. Now, these programs go through a series of transformations so that they can readily be used by machines. This is where language procedure systems come in handy.

High-Level Language to Machine Code
High-Level Language to Machine Code
High-Level Language: If a program contains pre-processor directives such as #include or #define it is called HLL. They are closer to humans but far from machines. These (#) tags are called preprocessor directives. They direct the pre-processor about what to do.
Pre-Processor: The pre-processor removes all the #include directives by including the files called file inclusion and all the #define directives using macro expansion. It performs file inclusion, augmentation, macro-processing, etc. For example: Let in the source program, it is written #include "Stdio. h". Pre-Processor replaces this file with its contents in the produced output.
Assembly Language: It's neither in binary form nor high level. It is an intermediate state that is a combination of machine instructions and some other useful data needed for execution.
Assembler: For every platform (Hardware + OS) we will have an assembler. They are not universal since for each platform we have one. The output of the assembler is called an object file. Its translates assembly language to machine code.
Compiler: The compiler is an intelligent program as compared to an assembler. The compiler verifies all types of limits, ranges, errors, etc. Compiler program takes more time to run and it occupies a huge amount of memory space. The speed of the compiler is slower than other system software. It takes time because it enters through the program and then does the translation of the full program.
Interpreter: An interpreter converts high-level language into low-level machine language, just like a compiler. But they are different in the way they read the input. The Compiler in one go reads the inputs, does the processing, and executes the source code whereas the interpreter does the same line by line. A compiler scans the entire program and translates it as a whole into machine code whereas an interpreter translates the program one statement at a time. Interpreted programs are usually slower concerning compiled ones.
Relocatable Machine Code: It can be loaded at any point and can be run. The address within the program will be in such a way that it will cooperate with the program movement.
Loader/Linker: Loader/Linker converts the relocatable code into absolute code and tries to run the program resulting in a running program or an error message (or sometimes both can happen). Linker loads a variety of object files into a single file to make it executable. Then loader loads it in memory and executes it.
Linker: The basic work of a linker is to merge object codes (that have not even been connected), produced by the compiler, assembler, standard library function, and operating system resources.
Loader: The codes generated by the compiler, assembler, and linker are generally re-located by their nature, which means to say, the starting location of these codes is not determined, which means they can be anywhere in the computer memory. Thus the basic task of loaders to find/calculate the exact address of these memory locations.
Overall, compiler design is a complex process that involves multiple stages and requires a deep understanding of both the programming language and the target platform. A well-designed compiler can greatly improve the efficiency and performance of software programs, making them more useful and valuable for users.


Phases of a Compiler
There are two major phases of compilation, which in turn have many parts. Each of them takes input from the output of the previous level and works in a coordinated way. 

Analysis Phase
An intermediate representation is created from the given source code : 

Lexical Analyzer
Syntax Analyzer
Semantic Analyzer
Intermediate Code Generator
Synthesis Phase
An equivalent target program is created from the intermediate representation. It has two parts : 

Code Optimizer
Code Generator
Read more about Phases of Compiler, Here.

Compiler Construction Tool

